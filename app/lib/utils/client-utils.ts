export const formatTime = (time: number): string => {
	const minutes = Math.floor(time / 60000);
	const seconds = Math.floor((time % 60000) / 1000);
	const milliseconds = time % 1000;
	return `${minutes}:${seconds.toString().padStart(2, "0")}.${milliseconds.toString().padStart(3, "0")}`;
};

type TextStyles = {
	bold?: boolean;
	italic?: boolean;
	wide?: boolean;
	narrow?: boolean;
	uppercase?: boolean;
	shadow?: boolean;
	link?: string;
};

type StyledSegment = {
	text: string;
	color: string; // Hex color
	styles: TextStyles;
};

// This utility function was generated by AI with help from docs:
// https://wiki.evotm.com/books/customization/page/text-styling
export const parseTrackmaniaStyledText = (input: string): StyledSegment[] => {
	const segments: StyledSegment[] = [];
	let i = 0;
	let currentColor = "#FFFFFF";
	let styles: TextStyles = {};
	let buffer = "";

	const hexColorRegex = /^[0-9A-Fa-f]{3}/;
	const styleMap: Record<string, keyof TextStyles> = {
		o: "bold",
		i: "italic",
		w: "wide",
		n: "narrow",
		t: "uppercase",
		s: "shadow",
	};

	function flushBuffer() {
		if (buffer.length > 0) {
			segments.push({
				text: styles.uppercase ? buffer.toUpperCase() : buffer,
				color: currentColor,
				styles: { ...styles },
			});
			buffer = "";
		}
	}

	while (i < input.length) {
		if (input[i] === "$") {
			// Handle escape $$
			if (input[i + 1] === "$") {
				buffer += "$";
				i += 2;
				continue;
			}

			// Handle color $RGB
			const colorMatch = input.slice(i + 1).match(hexColorRegex);
			if (colorMatch) {
				flushBuffer();
				const hex = colorMatch[0];
				const r = hex[0] + hex[0];
				const g = hex[1] + hex[1];
				const b = hex[2] + hex[2];
				currentColor = `#${r}${g}${b}`.toUpperCase();
				i += 1 + 3;
				continue;
			}

			// Handle styling $o, $i, $w, $n, $t, $s
			const styleChar = input[i + 1];
			if (styleChar && styleMap[styleChar]) {
				flushBuffer();
				const styleProperty = styleMap[styleChar];
				// Make sure we're only setting boolean properties to true
				if (styleProperty !== "link") {
					styles[styleProperty] = true;
				}
				i += 2;
				continue;
			}

			// Handle $g (reset color)
			if (styleChar === "g") {
				flushBuffer();
				currentColor = "#FFFFFF";
				i += 2;
				continue;
			}

			// Handle $z (reset all styling)
			if (styleChar === "z") {
				flushBuffer();
				styles = {};
				currentColor = "#FFFFFF";
				i += 2;
				continue;
			}

			// Handle $l (link)
			if (styleChar === "l") {
				flushBuffer();
				// Check for $l[link]text or $ltext
				if (input[i + 2] === "[") {
					// $l[link]Text
					const endBracket = input.indexOf("]", i + 3);
					if (endBracket !== -1) {
						const link = input.slice(i + 3, endBracket);
						styles.link = link;
						i = endBracket + 1;
						continue;
					}
				} else {
					// $lText (link is the text itself)
					styles.link = "";
					i += 2;
					continue;
				}
			}

			// Unrecognized $ code, treat as literal $
			buffer += "$";
			i += 1;
		} else {
			buffer += input[i];
			i += 1;
		}
	}
	flushBuffer();

	// If a link style was started but not used, clear it
	for (const seg of segments) {
		if (seg.styles.link === "") {
			seg.styles.link = seg.text;
		}
	}

	return segments;
};
